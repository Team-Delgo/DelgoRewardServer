package com.delgo.reward.fake;

import com.delgo.reward.certification.domain.Certification;
import com.delgo.reward.certification.service.port.CertRepository;
import com.delgo.reward.dto.comm.PageCustom;
import com.delgo.reward.dto.mungple.MungpleCountDTO;
import com.delgo.reward.dto.user.VisitCountDTO;
import com.delgo.reward.certification.domain.CertCondition;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FakeCertRepositoryImpl implements CertRepository {
    private final AtomicInteger autoGeneratedId = new AtomicInteger(0);

    private List<Certification> certifications;

    public FakeCertRepositoryImpl(List<Certification> certifications) {
        this.certifications = certifications;
    }

    @Override
    public PageCustom<Certification> findListByCondition(CertCondition condition) {
        Stream<Certification> stream = certifications.stream();

        if (condition.getUserId() != 0) {
            stream = stream.filter(cert -> cert.getUser().getUserId() == condition.getUserId());
        }
        if (condition.getMungpleId() != 0) {
            stream = stream.filter(cert -> cert.getMungpleId() == condition.getMungpleId());
        }
        if (condition.getDate() != null) {
            stream = stream.filter(cert -> cert.getRegistDt().isEqual(condition.getDate().atStartOfDay()));
        }
        if (condition.getIsCorrect() != null) {
            stream = stream.filter(cert -> cert.getIsCorrect() == condition.getIsCorrect());
        }

        List<Certification> filteredList = stream.collect(Collectors.toList());

        // unPaged 처리
        if (condition.getPageable().isUnpaged()) {
            return new PageCustom<>(filteredList, filteredList.size(), 0, true, filteredList.size());
        }

        // 페이징 처리
        int start = (int) condition.getPageable().getOffset();
        int end = Math.min((start + condition.getPageable().getPageSize()), filteredList.size());
        List<Certification> pagedList = filteredList.subList(start, end);

        boolean isLast = end == filteredList.size();

        return new PageCustom<>(pagedList, condition.getPageable().getPageSize(), condition.getPageable().getPageNumber(), isLast, filteredList.size());
    }

    @Override
    public Optional<Certification> findByCertId(Integer certificationId) {
        return certifications.stream()
                .filter(cert -> cert.getCertificationId() == certificationId)
                .findFirst();
    }

    @Override
    public Certification save(Certification certification) {
        return Certification.builder()
                .certificationId(autoGeneratedId.incrementAndGet())
                .placeName(certification.getPlaceName())
                .description(certification.getDescription())
                .mungpleId(certification.getMungpleId())
                .categoryCode(certification.getCategoryCode())
                .address(certification.getAddress())
                .isHideAddress(certification.getIsHideAddress())
                .geoCode(certification.getGeoCode())
                .pGeoCode(certification.getPGeoCode())
                .latitude(certification.getLatitude())
                .longitude(certification.getLongitude())
                .isCorrect(certification.getIsCorrect())
                .commentCount(certification.getCommentCount())
                .user(certification.getUser())
                .registDt(LocalDate.now().atStartOfDay())
                .build();
    }

    @Override
    public void deleteById(int certificationId) {
        certifications.removeIf(cert -> cert.getCertificationId() == certificationId);
    }

    @Override
    public void deleteByUserId(int userId) {
        certifications.removeIf(cert -> cert.getUser().getUserId() == userId);
    }


    @Override
    public List<MungpleCountDTO> countGroupedByMungpleId() {
        Map<Integer, Long> countMap = certifications.stream()
                .collect(Collectors.groupingBy(Certification::getMungpleId, Collectors.counting()));

        return countMap.entrySet().stream()
                .map(entry -> new MungpleCountDTO(entry.getKey(), entry.getValue().intValue()))
                .collect(Collectors.toList());
    }

    @Override
    public Integer countOfCorrectByMungpleId(int mungpleId) {
        return (int) certifications.stream()
                .filter(cert -> cert.getMungpleId() == mungpleId && cert.getIsCorrect())
                .count();
    }

    @Override
    public List<VisitCountDTO> findVisitCountDTOList(int userId, Pageable pageable) {
        return null;
    }
}
